import os
import numpy as np
import sys

from Chandra.Time import DateTime
from Ska.engarchive import fetch_eng as fetch

os.environ["SKA_DATA"] = "/proj/sot/ska/data"
home = os.path.expanduser("~")
sys.path.append(home + '/AXAFLIB/pylimmon/')
import pylimmon




def check_violations(thermdict, t1, t2):
    """Check a list of MSIDs for limit/expected state violations.

    :param thermdict: Dictionary of MSID information (MSID name, condition type, etc.)
    :param t1: String containing start date in HOSC format
    :param t2: String containgin stop date in HOSC format
    
    Note: The thermdict object is structured with each 'Ska' msid as the primary key for
    each sub-dictionary. Each sub-dictionary has these keys: 'type', 'greta_msid'. The
    type is either 'limit' or 'expst'. The greta_msid is used to identify the mnemonic
    used by GRETA which in some cases differs from the mnemonic used by Ska (e.g. widerange
    thermal MSIDs).

    """
    t1 = DateTime(t1).date
    t2 = DateTime(t2).date

    allviolations = {}
    missingmsids = []
    checkedmsids = []
    for key in thermdict.keys():
        greta_msid = thermdict[key]['greta_msid']
        try:
            if thermdict[key]['type'] == 'limit':
                if "wide" in greta_msid.lower():
                    violations = handle_widerange_cases(key, t1, t2, greta_msid)
                    checkedmsids.append(key)
                else:
                    violations = pylimmon.check_limit_msid(key, t1, t2, greta_msid=greta_msid)
                    checkedmsids.append(key)
            elif thermdict[key]['type'] == 'expst':
                violations = pylimmon.check_state_msid(key, t1, t2, greta_msid=greta_msid)
                checkedmsids.append(key)

            if len(violations) > 0:
                allviolations[key] = process_violations(key, violations)

        except IndexError:
            print('{} not in DB'.format(key))
            missingmsids.append(key)

    return allviolations, missingmsids, checkedmsids


def handle_widerange_cases(key, t1, t2, greta_msid):
    """Handle special widerange MSIDs.

    :param key: Name of MSID as represented in Ska Engineering Archive
    :param t1: String containing start time in HOSC format
    :param t2: String containgin stop time in HOSC format
    :greta_msid: Name of MSID as represented in GRETA

    Note: Some MSID names differ between Ska and GRETA. Widerange MSIDs are one such case. For 
    example OOBTHR35 is used for this measurement in both Ska and GRETA before this MSID was
    switched to widerange read mode. Afterwards GRETA uses OOBTHR35_WIDE whereas Ska still uses
    OOBTHR35 for continuity.
    """
    if DateTime(t2).secs <= DateTime('2014:342:16:30:00').secs:
        violations = pylimmon.check_limit_msid(key, t1, t2, greta_msid=key)
    elif DateTime(t1).secs >= DateTime('2014:342:16:33:00').secs:
        violations = pylimmon.check_limit_msid(key, t1, t2, greta_msid=greta_msid)
    else:
        t2_a = np.min((DateTime(t2).secs, DateTime('2014:342:16:30:00').secs))
        violations = pylimmon.check_limit_msid(key, t1, t2_a, greta_msid=key)
        t1_b = np.min((DateTime(t2).secs, DateTime('2014:342:16:33:00').secs))
        violations_b = pylimmon.check_limit_msid(key, t1_b, t2, greta_msid=greta_msid)

        violations.extend(violations_b)

    return violations


def process_violations(msid, violations):
    """Add contextual information for any limit/expected state violations.

    :param msid: Current mnemonic
    :param violations: List of individual violations (list of tuples) generated by the pylimmon
                       'check_limit_msid' or 'check_state_msid' functions.

    """
    data = fetch.Msid(msid, violations[0][0][0], violations[0][0][-1], stat='5min')
    try:
        desc = data.tdb.technical_name
    except:
        desc = 'No Description in TDB'

    violation_dict = {}
    for v in violations:
        limtype = v[-1]
        if 'high' in limtype.lower():
            if limtype not in violation_dict.keys():
                violation_dict.update({limtype: {'starttime': v[0][0], 'stoptime': v[0][-1],
                                                 'num_excursions': 1, 'extrema': np.max(v[1]),
                                                 'limit': v[2][0], 'setid': v[3][0],
                                                 'duration': v[0][-1] - v[0][0]}})
            else:
                violation_dict[limtype]['extrema'] = np.max(
                    (np.max(v[1]), violation_dict[limtype]['extrema']))
                violation_dict[limtype]['starttime'] = np.min(
                    (v[0][0], violation_dict[limtype]['starttime']))
                violation_dict[limtype]['stoptime'] = np.max(
                    (v[0][0], violation_dict[limtype]['stoptime']))
                violation_dict[limtype]['num_excursions'] = violation_dict[
                    limtype]['num_excursions'] + 1
                violation_dict[limtype]['duration'] = violation_dict[
                    limtype]['duration'] + v[0][-1] - v[0][0]

        elif 'low' in limtype.lower():
            if limtype not in violation_dict.keys():
                violation_dict.update({limtype: {'starttime': v[0][0], 'stoptime': v[0][-1],
                                                 'num_excursions': 1, 'extrema': np.min(v[1]),
                                                 'limit': v[2][0], 'setid': v[3][0],
                                                 'duration': v[0][-1] - v[0][0]}})
            else:
                violation_dict[limtype]['extrema'] = np.min(
                    (np.min(v[1]), violation_dict[limtype]['extrema']))
                violation_dict[limtype]['starttime'] = np.min(
                    (v[0][0], violation_dict[limtype]['starttime']))
                violation_dict[limtype]['stoptime'] = np.max(
                    (v[0][0], violation_dict[limtype]['stoptime']))
                violation_dict[limtype]['num_excursions'] = violation_dict[
                    limtype]['num_excursions'] + 1
                violation_dict[limtype]['duration'] = violation_dict[
                    limtype]['duration'] + v[0][-1] - v[0][0]

        elif 'state' in limtype.lower():
            if limtype not in violation_dict.keys():
                violation_dict.update({limtype: {'starttime': v[0][0], 'stoptime': v[0][-1],
                                                 'num_excursions': 1, 'extrema': v[1][0],
                                                 'limit': v[2][0], 'setid': v[3][0],
                                                 'duration': v[0][-1] - v[0][0]}})
            else:
                violation_dict[limtype]['starttime'] = np.min(
                    (v[0][0], violation_dict[limtype]['starttime']))
                violation_dict[limtype]['stoptime'] = np.max(
                    (v[0][0], violation_dict[limtype]['stoptime']))
                violation_dict[limtype]['num_excursions'] = violation_dict[
                    limtype]['num_excursions'] + 1
                violation_dict[limtype]['duration'] = violation_dict[
                    limtype]['duration'] + v[0][-1] - v[0][0]

    for limittype in ['warning_low', 'caution_low', 'caution_high', 'warning_high', 'state']:
        if limittype in violation_dict.keys():
            violation_dict[limittype]['duration'] = violation_dict[limittype]['duration'] / 3600.
            violation_dict[limittype]['description'] = desc
            violation_dict[limittype]['startdate'] = DateTime(
                violation_dict[limittype]['starttime']).date
            violation_dict[limittype]['stopdate'] = DateTime(
                violation_dict[limittype]['stoptime']).date

    return violation_dict
